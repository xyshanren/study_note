<!--
 * @Autor: 逍遥山人
 * @Date: 2019-12-19 17:30:22
 * @LastEditors: 李逍遥
 * @LastEditTime: 2021-03-09 06:51:06
 * @Descriptiong: 
 -->

# MySQL日常使用笔记 #

>逍遥山人的MySQL使用笔记，持续更新中  

- [MySQL日常使用笔记](#mysql日常使用笔记)
  - [服务](#服务)
    - [查看服务属性](#查看服务属性)
    - [字符集和字符序](#字符集和字符序)
  - [库](#库)
  - [表定义](#表定义)
    - [增](#增)
    - [删和改](#删和改)
    - [查](#查)
  - [注释](#注释)
  - [DML](#dml)
    - [INSERT](#insert)
    - [UPDATE](#update)
    - [DELETE](#delete)
  - [DQL](#dql)
    - [SELECT](#select)
    - [连接](#连接)
    - [information_schema.tables](#information_schematables)
    - [show语句](#show语句)
    - [日期或时间格式化](#日期或时间格式化)
    - [正则表达式（regexp）](#正则表达式regexp)
    - [实现分组排序，类似开窗函数](#实现分组排序类似开窗函数)
  - [索引](#索引)
    - [创建索引](#创建索引)
    - [删除索引](#删除索引)
    - [查看表的索引](#查看表的索引)
  - [执行计划管理（基础优化）](#执行计划管理基础优化)
    - [获取执行计划](#获取执行计划)
  - [过程，作业和触发器](#过程作业和触发器)

## 服务 ##

### 查看服务属性 ###

```sql
# 查看所有属性（参数）
show variables;
# 查看表名大小写是否敏感配置
show variables like '%lower_case_table_names%';
```

>**lower_case_table_names**
>表名大小写是否敏感
>取值有三个，分别是0、1、2
>Linux、Windows、Mac OS中默认值分别是 0 1 2
>0：表名按你写的SQL大小写存储，大写就大写小写就小写，比较时大小写敏感。
>1：表名转小写后存储到硬盘，比较时大小写不敏感。
>2：表名按你写的SQL大小写存储，大写就大写小写就小写，比较时统一转小写比较。

### 字符集和字符序 ###

- 查看支持的字符集  

  ```sql
  SHOW CHARACTER SET;
  # 还可以加上限制条件 where 或 like
  SHOW CHARACTER SET WHERE Charset="utf8";
  SHOW CHARACTER SET LIKE "utf8%";
  # 或者
  use information_schema;
  select * from CHARACTER_SETS;
  ```

- 查看支持的字符序  

  ```sql
  # 通过Default的值是否为Yes，判断是否默认的字符序
  SHOW COLLATION;
  # 或者
  USE information_schema;
  SELECT * FROM COLLATIONS WHERE CHARACTER_SET_NAME="utf8";
  ```

- 查看字符集和字符序  

  ```sql
  # 查看 字符集
  show variables like 'character_set_server%';
  # 查看 字符序
  show variables like 'collation_server%';
  # 查看数据库的字符集字符序
  use 库名;
  SELECT @@character_set_database, @@collation_database;
  # 也可以通过系统表来查看字符集字符序
  SELECT SCHEMA_NAME, DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME  FROM information_schema.SCHEMATA WHERE schema_name="库名";
  # 还可以通过查看建库语句来查看
  ```

>**字符集、字符序的概念与联系**  
>在数据的存储上，MySQL提供了不同的字符集支持。而在数据的对比操作上，则提供了不同的字符序支持。  
>MySQL提供了不同级别的设置，包括server级、database级、table级、column级，可以提供非常精准的设置。  
>**什么是字符集、字符序？简单的来说：**  
>*1.字符集（character set/charset）：定义了字符以及字符的编码。*  
>*2.字符序（collation）：也叫排序规则或者校对规则，定义了字符的比较规则。*  
>**MySQL支持多种字符集 与 字符序：**  
>*1.一个字符集对应至少一种字符序（一般是1对多）。*  
>*2.两个不同的字符集不能有相同的字符序。*  
>*3.每个字符集都有默认的字符序。*

具体的情况见：[MySQL的字符集设置](https://www.cnblogs.com/chyingp/p/mysql-character-set-collation.html '再见乱码')

## 库 ##

- 查看所有的库名

  ```sql
  SHOW DATABASES;
  ```

  或者使用系统表，除库名外还能得到数据库配置信息

  ```sql
  SELECT
      lower(schema_name) schema_name
  FROM
      information_schema.schemata
  WHERE
      schema_name NOT IN (
          'mysql',
          'information_schema',
          'test',
          'search',
          'tbsearch',
          'sbtest',
          'dev_ddl'
      );
  ```

- 查看建库语句  

  ```sql
  SHOW CREATE DATABASE 数据库名;
  ```

- 创建、修改和删除  

  ```sql
  -- 按照默认的字符集和排序规则创建数据库
  CREATE DATABASE 库名;
  -- 指定字符集和排序规则（也可以使用charset，也可以不用引号）
  CREATE DATABASE 库名 CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_unicode_ci';
  -- 创建数据库时如果已存在会报错，避免报错可以先判断是否存在
  CREATE DATABASE IF NOT EXISTS 库名;
  -- 修改数据库的字符集、字符序（也可以使用charset）
  ALTER DATABASE db_name [[DEFAULT] CHARACTER SET charset_name] [[DEFAULT] COLLATE collation_name];
  -- 删除库
  DROP DATABASE 库名;
  ```

- 查看数据库中的所有表的信息  

  ```sql
  SELECT
      table_name,
      create_time updated_at,
      table_type,
      ENGINE,
      table_rows num_rows,
      table_comment,
      ceil(data_length / 1024 / 1024) store_capacity
  FROM
      information_schema.TABLES
  WHERE
      table_schema = '库名' AND table_name NOT LIKE 'tmp#_%' ESCAPE '#';
  ```

- 查询库中所有 innodb 引擎的表

  ```sql
  SELECT
      table_name,
      table_type,
      engine,
      table_rows num_rows,
      table_comment
  FROM
      information_schema.TABLES
  WHERE
      table_schema = '库名' AND engine = 'innodb';
  ```

- 判断库中是否存在包含`status`的表

  ```sql
  SELECT table_name FROM information_schema.TABLES WHERE table_name LIKE '%status%';
  ```

- 查看库表

  ```sql
  show databases;
  show tables [from database];
  ```

## 表定义 ##

### 增 ###

- 一般建表格式

  ```sql
  CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
      (create_definition,...)


  create_definition: {
      col_name column_definition
    | {INDEX | KEY} [index_name] [index_type] (key_part,...)
        [index_option] ...
    | {FULLTEXT | SPATIAL} [INDEX | KEY] [index_name] (key_part,...)
        [index_option] ...
    | [CONSTRAINT [symbol]] PRIMARY KEY
        [index_type] (key_part,...)
        [index_option] ...
    | [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY]
        [index_name] [index_type] (key_part,...)
        [index_option] ...
    | [CONSTRAINT [symbol]] FOREIGN KEY
        [index_name] (col_name,...)
        reference_definition
    | CHECK (expr)
  }

  column_definition: {
      data_type [NOT NULL | NULL] [DEFAULT default_value]
        [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]
        [COMMENT 'string']
        [COLLATE collation_name]
        [COLUMN_FORMAT {FIXED | DYNAMIC | DEFAULT}]
        [STORAGE {DISK | MEMORY}]
        [reference_definition]
    | data_type
        [COLLATE collation_name]
        [GENERATED ALWAYS] AS (expr)
        [VIRTUAL | STORED] [NOT NULL | NULL]
        [UNIQUE [KEY]] [[PRIMARY] KEY]
        [COMMENT 'string']
        [reference_definition]
  }

  data_type:
      (see Chapter 11, Data Types)

  # 可省略
  key_part:
      col_name [(length)] [ASC | DESC]

  # 可省略
  index_type:
      USING {BTREE | HASH}

  # 可省略
  index_option: {
      KEY_BLOCK_SIZE [=] value
    | index_type
    | WITH PARSER parser_name
    | COMMENT 'string'
  }

  # 外键配置，一般用不到
  reference_definition:
      REFERENCES tbl_name (key_part,...)
        [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]
        [ON DELETE reference_option]
        [ON UPDATE reference_option]

  # 外键配置，可省略
  reference_option:
      RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT

  ```

  >详细信息参照官方文档：<https://dev.mysql.com/doc/refman/5.7/en/create-table.html>
  >另外，还可以使用 create table tbl_name like o_tbl_name 来复制表结构，还可以使用 as select 建表；

- 新建表以及添加表和字段的注释（还可以指定引擎、字符集等，字符集也可以使用charset）

  ```sql
  create table tbl_name(
      ID INT(11) primary key auto_increment  comment '主键',
      NAME VARCHAR(255) comment '姓名',
      CREATE_TIME datetime comment '创建时间'
  )comment  = '用户信息表'
  [engine=innodb]
  [[DEFAULT] CHARACTER SET charset_name]
  [COLLATE collation_name]];
  ```

  建议建表模板示例

  ```sql
  create table tbl_name(
  id int not null primary key AUTO_INCREMENT comment '编号',
  name varchar(255) not null comment '姓名',
  age tinyint unsigned not null default 0 comment '年龄',
  gender enum('m','f','n') not null default 'n' comment '性别',
  create_time datetime not null default now() comment '创建时间'
  ) charset=utf8mb4 engine=innodb;
  ```

- 增加字段（列）

  ```sql
  # 以手机号为例
  alter table tbl_name add column_name char(11) not null unique comment '手机号';
  # 添加一个状态列
  alter table tbl_name add state tinyint unsigned not null default 1 comment '状态';
  # 指定加入列的位置可使用 after col_name 命令,例如在 name 后添加 qq列
  alter table tbl_name add qq varchar(255) not null unique comment 'qq' after name;
  # 指定加入列在首列可使用 first 命令，例如在首列上添加 学号列：sid
  ater table tbl_name add sid varchar(255) not null unique comment '学号' first;
  ```

### 删和改 ###

- 删表

  ```sql
  drop table tbl_name;
  ```

- 删列（字段）

  ```sql
  alter table tbl_name drop column_name;
  ```

- 修改表的字符集、字符序

  ```sql
  ALTER TABLE tbl_name [[DEFAULT] CHARACTER SET charset_name] [COLLATE collation_name];
  ```

- 修改字段类型、注释等

    ```sql
    alter table tbl_name modify column column_name varchar(30) comment "注释";
    ```

- 既修改字段名也修改字段类型等

  ```sql
  # 例如
  alter table tbl_name change old_col_name new_col_name char(1) not null default 'n';
  ```

### 查 ###

- 查看表结构  
  查看表的字段、字段类型、索引等

    ```sql
    DESC tbl_name;
    SHOW COLUMNS FROM tbl_name;
    # 包含字符集、字段注释等
    SHOW FULL FIELDS FROM tbl_name;
    ```

- 查看数据库下某(些)表的字段信息  

  ```sql
  SELECT
      lower(column_name) column_name,
      ordinal_position position,
      column_default dafault_value,
      substring(is_nullable, 1, 1) nullable,
      column_type data_type,
      column_comment,
      character_maximum_length data_length,
      numeric_precision data_precision,
      numeric_scale data_scale
  FROM
      information_schema.COLUMNS
  WHERE
      table_schema = 'employees' AND table_name = 'employees';
  ```

- 查看建表语句

    >注意表名不加单引号

    ```sql
    show create table 表名;
    ```

- 查看分区表的分区情况

    ```sql
    SELECT
        partition_name part,
        partition_expression expr,
        partition_description descr,
        table_rows
    FROM
        information_schema.PARTITIONS
    WHERE
        table_schema = SCHEMA()
    AND table_name = 'table_name';
    ```

    >分区操作参考：<http://blog.csdn.net/youzhouliu/article/details/52757043>

- 修改表或字段的字符集
  - 修改表的默认字符集和所有字符列的字符集

    ```sql
    ALTER TABLE tbl_name CONVERT TO CHARACTER SET character_name [COLLATE ...]
    -- 例如：
    ALTER TABLE tbl_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
    ```

  - 只修改表的默认字符集

    ```sql
    ALTER TABLE tbl_name DEFAULT CHARACTER SET character_name [COLLATE...];
    ```

## 注释 ##

- 修改表/字段的注释

    ```sql
    alter table t_user comment  = '修改后的表注释信息(用户信息表)';
    ```

- 修改字段注释

    ```sql
    alter table t_user modify column id int comment '主键ID';
    ```

- 查看所有表的注释

    ```sql
    SELECT table_name 表名, table_comment 表说明
    FROM information_schema.TABLES
    WHERE table_schema = '数据库名'
    ORDER BY table_name;
    ```

- 查询所有表及字段的注释

    ```sql
    SELECT
        a.table_name 表名,
        a.table_comment 表说明,
        b.COLUMN_NAME 字段名,
        b.column_comment 字段说明,
        b.column_type 字段类型,
        b.column_key 约束
    FROM information_schema.TABLES a
    LEFT JOIN information_schema. COLUMNS b ON a.table_name = b.TABLE_NAME
    WHERE a.table_schema = '数据库名'
    ORDER BY a.table_name;
    ```

- 查询某表的所有字段的注释

    ```sql
    select
        COLUMN_NAME 字段名,
        column_comment 字段说明,
        column_type 字段类型,
        column_key 约束
    from information_schema.columns
    where table_schema = '数据库名' and table_name = '表名';
    # 或者
    show full columns from 表名;
    ```

## DML ##

### INSERT ###

```sql
# 简单写法，省略字段，值需要与列定义一一对应
insert into tbl_name values(xx,xx...);
# 规范写法，指定录入字段，值与列一一对应
insert into tbl_name(col1,col2...) values (xx,xx...);
# 插入多行
insert into tbl_name(col1,col2...) values (xx,xx...),(xx,xx...),(xx,xx...);
```

### UPDATE ###

>谨慎在数据库中做 update 操作

```sql
# 标准格式 update set where
update tbl_name set col_name = 'xxx' where id = x;
```

### DELETE ###

>谨慎在数据库中做 delete 操作

```sql
# 删除表中所有数据
delete from tbl_name;
# 删除指定行数据
delete from tbl_name where id = x;
# 清空表数据（物理删除，效率更高）
truncate table tbl_name;
```

>delete 与 truncate 的区别：
>delete 是逻辑逐行删除，不会降低自增长的起始值，效率很低，产生很多磁盘碎片，会影响性能；
>truncate 是物理删除，将表段中的区页进行清空，不会产生碎片，效率较高。

## DQL ##

>官方文档中没有DQL，属于DML，这里单独列出来。

### SELECT ###

- 单独使用select
  - select @@xxxx;
    获取参数信息。

    ```sql
    # 获取端口号
    select @@port;
    -- 查看默认的引擎
    select @@default_storage_engine;
    # 参数名记忆不准确的话，可以使用模糊匹配
    show variables like '%xx%';
    ```

  - select 函数();

    ```sql
    # 常用的
    # 查看当前数据库
    select database();
    # 查看当前时间
    select database();
    # 查看当前版本
    select version();
    ```

- SQL92标准的使用语法

  - MySQL的world示例库
    加载官方提供的示例数据库：<https://dev.mysql.com/doc/index-other.html>
    以下使用示例都用该库的表进行示范，表结构如下：

    ```sql
    CREATE TABLE `city` (
      `ID` int NOT NULL AUTO_INCREMENT,
      `Name` char(35) NOT NULL DEFAULT '',
      `CountryCode` char(3) NOT NULL DEFAULT '',
      `District` char(20) NOT NULL DEFAULT '',
      `Population` int NOT NULL DEFAULT '0',
      PRIMARY KEY (`ID`),
      KEY `CountryCode` (`CountryCode`),
      CONSTRAINT `city_ibfk_1` FOREIGN KEY (`CountryCode`) REFERENCES `country` (`Code`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

    CREATE TABLE `country` (
      `Code` char(3) NOT NULL DEFAULT '',
      `Name` char(52) NOT NULL DEFAULT '',
      `Continent` enum('Asia','Europe','North America','Africa','Oceania','Antarctica','South America') NOT NULL DEFAULT 'Asia',
      `Region` char(26) NOT NULL DEFAULT '',
      `SurfaceArea` decimal(10,2) NOT NULL DEFAULT '0.00',
      `IndepYear` smallint DEFAULT NULL,
      `Population` int NOT NULL DEFAULT '0',
      `LifeExpectancy` decimal(3,1) DEFAULT NULL,
      `GNP` decimal(10,2) DEFAULT NULL,
      `GNPOld` decimal(10,2) DEFAULT NULL,
      `LocalName` char(45) NOT NULL DEFAULT '',
      `GovernmentForm` char(45) NOT NULL DEFAULT '',
      `HeadOfState` char(60) DEFAULT NULL,
      `Capital` int DEFAULT NULL,
      `Code2` char(2) NOT NULL DEFAULT '',
      PRIMARY KEY (`Code`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

    CREATE TABLE `countrylanguage` (
      `CountryCode` char(3) NOT NULL DEFAULT '',
      `Language` char(30) NOT NULL DEFAULT '',
      `IsOfficial` enum('T','F') NOT NULL DEFAULT 'F',
      `Percentage` decimal(4,1) NOT NULL DEFAULT '0.0',
      PRIMARY KEY (`CountryCode`,`Language`),
      KEY `CountryCode` (`CountryCode`),
      CONSTRAINT `countryLanguage_ibfk_1` FOREIGN KEY (`CountryCode`) REFERENCES `country` (`Code`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
    ```

  - select语法执行顺序（单表）
    select 开始 -> from子句 -> where子句 -> group by子句 -> select后的执行条件（列显示）-> having子句 --> order by -> limit

  - from 【必选】

    ```sql
    # 简单用法
    # 适合表数据行较少的，生产中慎用
    use database;
    # 例子，查全部数据
    select * from city;
    # 例子，查看部分字段的数据
    SELECT id,NAME,countrycode FROM city;
    ```

  - where
    筛选过滤

    ```sql
    # 示例
    # 1.where 配合 等值查询
    -- 查询中国的城市信息
    SELECT id,NAME,countrycode FROM city WHERE countrycode = 'CHN';

    # 2.where 配合 不等值查询（> < >= <= <> !=）
    -- 查询人口小于100人的城市
    SELECT * FROM city WHERE population < 100;
    -- 查询人口大于1千万的城市
    SELECT * FROM city WHERE population > 10000000;
    
    # 3.where 配合 模糊查询
    -- 查询国家代号是C开头的国家
    SELECT * FROM city WHERE countrycode LIKE 'C%';
    # 注意：like语句在MySQL中，尽量不要使用左%，因为效率低，不走索引。

    # 4.where 配合 逻辑连接符（and or）
    SELECT * FROM city WHERE population > 10000 and population < 20000;
    SELECT id,NAME,countrycode,population FROM city WHERE countrycode in ('CHN','USA');
    ## 以上语句建议改写为以下语句
    SELECT id,NAME,countrycode,population FROM city WHERE countrycode = 'CHN'
    union all
    SELECT id,NAME,countrycode,population FROM city WHERE countrycode = 'USA';
    ```

  - group by 配合聚合函数应用
    聚合函数：
    avg()
    count()
    sum()
    max()
    min()
    group_concat()

    ```sql
    # 示例
    -- 统计每个国家的总人口
    SELECT countrycode,SUM(population) AS pop_cnt FROM city GROUP BY countrycode;
    -- 统计每个国家的城市个数
    SELECT countrycode,COUNT(population) AS cnt FROM city GROUP BY countrycode;
    -- 统计并显示每个国家的省名称列表
    SELECT countrycode,COUNT(DISTINCT district) AS dis_cnt,GROUP_CONCAT(DISTINCT district) AS dis_list FROM city GROUP BY countrycode;
    -- 统计并列出中国每个省的城市名列表
    SELECT district,COUNT(1) AS cnt,GROUP_CONCAT(NAME) AS city_list FROM city WHERE countrycode = 'CHN' GROUP BY district;
    ```

  - having
    group by分组后对结果进行过滤

    ```sql
    -- 统计中国省的总人口大于1000w的省
    SELECT district,SUM(population) AS pop_cnt FROM city WHERE countrycode = 'CHN' GROUP BY district having sum(population) > 10000000;
    ```

  - order by
    排序 asc/desc

  - limit

    ```sql
    # 示例
    SELECT * FROM city WHERE countrycode = 'CHN' ORDER BY population LIMIT 10;
    SELECT * FROM city WHERE countrycode = 'CHN' ORDER BY population LIMIT 3,5;
    SELECT * FROM city WHERE countrycode = 'CHN' ORDER BY population LIMIT 5 OFFSET 3;
    -- 总结
    -- limit m,n 跳过m行，显示n行
    -- limit x offset y 跳过y行显示x行
    ```

### 连接 ###

- 交叉连接（CROSS JOIN）  
  交叉连接，得到的结果是两个表的乘积，即笛卡尔积。
  使用交叉连接的时候，结果集由第一个表的所有行与第二个表的所有行的结合，表之间不需要关系；  
  **适合用于**展现两个数据集的所有可能的组合情况，比如在统计中构造连续的数据。
  例如：统计每天/周/月的(交易等)数据，为使每天/周/月都有数据，可用交叉连接的方式构造数据；  
  使用形式如下：  

    ```sql
    SELECT  *
    FROM T1
    CROSS JOIN T2;
    ```

>优化点：使用左外连接指定驱动表（小表）来优化内连接；

### information_schema.tables ###

元数据储存在基表（无法直接查询和修改）中
-> 使用 DDL 进行元数据修改
-> 使用 show,desc,information_schema(全局的统计和查询) 查看元数据。

最常用到的表是 tables ，主要关注的字段如下：

```sql
-- 进入库
use information_schema
-- 查看tables表字段
desc tables;
-- 主要关注以下字段
TABLE_SCHEMA    表所在的库
TABLE_NAME      表名
ENGINE          表的存储引擎
TABLE_ROWS      表的行数
AVG_ROW_LENGTH  平均行长度
INDEX_LENGTH    索引的长度
```

常用的查询语句如下：

```sql
-- 查询整个数据库中所有的库对应的表名
SELECT TABLE_SCHEMA,TABLE_NAME FROM information_schema.TABLES;
-- 查询某个库中的表
SELECT TABLE_SCHEMA,TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA = 'world';

-- 统计每个库的真实数据量
-- 每张表的数据量=AVG_ROW_LENGTH*TABLE_ROWS+INDEX_LENGTH
SELECT TABLE_SCHEMA,SUM(AVG_ROW_LENGTH * TABLE_ROWS + INDEX_LENGTH)/1024/1024 AS size_mb
FROM information_schema.TABLES
GROUP BY TABLE_SCHEMA;

-- tables表 + concat()函数拼接命令

-- 实例1，生产中往往需要备份某些表，例如以下命令
-- mysqldump -uroot -p123 world city >/tmp/world_city.sql
-- 模仿以上命令，对整个数据库下的1000（很多）张表进行单独备份，并排除掉系统库
SELECT CONCAT("mysqldump -uroot -p123 ",TABLE_SCHEMA," ",table_name," >/tmp/",table_schema,"_",table_name,".sql")
FROM information_schema.TABLES
WHERE TABLE_SCHEMA NOT IN ('information_schema','mysql','performance_schema','sys')
INTO OUTFILE '/tmp/bak.sh';
-- 注意：my.cnf中需要设置 secure-file-priv=/tmp

-- 实例2，模仿以下语句，批量实现world库下所有表的操作语句生成
-- alter table world.city discard tablespace;
SELECT CONCAT("alter table ",table_schema,".",table_name," discard tablespace;")
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = "world";
```

### show语句 ###

```sql
-- 查看所有库名
show databases;
-- 查看当前库下的所有表
show tables;
-- 查看world库下的所有表
show tables form world;
-- 查看建库语句
show create database world;
-- 查看建表语句
show create table city;
-- 查看用户权限信息
show grants for root@'localhost';
-- 查看所有的字符集
show charset;
-- 查看校对规则
show collation;
-- 查看数据库的连接情况
show full processlist;
-- 查看数据库的整体状态
show status;
-- 模糊查看数据库的状态
show status like '%lock%';
-- 查看数据库所有的参数情况
show variables;
show variables like '%character%';
-- 查看所有支持的存储引擎
show engines;
-- 查看默认的引擎
show variables like 'default_storage_engine';
-- 查看所有innodb存储引擎状态情况
show engine innodb status;
-- 查看二进制日志情况
show binary logs;
-- 查看二进制日志事件
show binlog events in;
-- 查看relay日志事件
show relaylog events in;
-- 查看从库状态
show slave status;
-- 查看数据库binlog位置信息
show master status;
-- 查看表的索引情况
show index from city;
```

### 日期或时间格式化 ###

- 格式化(date_format)  
  定义  
  DATE_FORMAT() 函数用于以不同的格式显示日期/时间数据。  

  语法  

    ```sql
    DATE_FORMAT(date,format)
    ```

  >date 参数是合法的日期。format 规定日期/时间的输出格式。

  可以使用的格式有：  
  |模式|描述|
  |:--|:--|
  |%a|缩写星期名|
  |%b|缩写月名|
  |%c|月，数值|
  |%D|带有英文前缀的月中的天|
  |%d|月的天，数值(00-31)|
  |%e|月的天，数值(0-31)|
  |%f|微秒|
  |%H|小时 (00-23)|
  |%h|小时 (01-12)|
  |%I|小时 (01-12)|
  |%i|分钟，数值(00-59)|
  |%j|年的天 (001-366)|
  |%k|小时 (0-23)|
  |%l|小时 (1-12)|
  |%M|月名|
  |%m|月，数值(00-12)|
  |%p|AM 或 PM|
  |%r|时间，12-小时（hh:mm:ss AM 或 PM）|
  |%S|秒(00-59)|
  |%s|秒(00-59)|
  |%T|时间, 24-小时 (hh:mm:ss)|
  |%U|周 (00-53) 星期日是一周的第一天|
  |%u|周 (00-53) 星期一是一周的第一天|
  |%V|周 (01-53) 星期日是一周的第一天，与 %X 使用|
  |%v|周 (01-53) 星期一是一周的第一天，与 %x 使用|
  |%W|星期名|
  |%w|周的天 （0=星期日, 6=星期六）|
  |%X|年，其中的星期日是周的第一天，4 位，与 %V 使用|
  |%x|年，其中的星期一是周的第一天，4 位，与 %v 使用|
  |%Y|年，4 位|
  |%y|年，2 位|

  示例：  

    ```sql
    SELECT date_format(CURDATE(), '%Y-%m-%d %h:%m:%s');
    SELECT date_format(CURDATE(), '%Y/%m/%d');
    SELECT STR_TO_DATE('2016-08-08', '%Y-%m-%d %h:%m:%s');
    SELECT DATE_FORMAT(NOW(),'%Y%m%d');
    ```

- 毫秒数与日期转化

    ```sql
    -- 毫秒数转化为日期
    select FROM_UNIXTIME(1364176514656/1000,'%Y-%m-%d %h:%i:%s') as dt;
    -- 日期转化为毫秒数
    select UNIX_TIMESTAMP('2011-05-31 23:59:59');
    ```

### 正则表达式（regexp） ###

- 操作符  
  |模式|描述|
  |:--|:--|
  |^|匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置|
  |$|匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置|
  |.|匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式|
  |[...]|字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'|
  |[^...]|负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'|
  |p1\|p2\|p3|匹配 p1 或 p2 或 p3。例如，'z\|food' 能匹配 "z" 或 "food"。'(z\|f)ood' 则匹配 "zood" 或 "food"|
  |* |匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}|
  |+|匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}|
  |{n}|n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o|
  |{n,m}|m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次|

- 实例
  - 匹配连续数字

    ```sql
    SELECT * FROM ofchatlog a WHERE a.`sender` REGEXP 'jf[0-9]{5}' LIMIT 10;
    ```

  - 匹配三个字符串(或的关系)

    ```sql
    SELECT *
    FROM ofchatlog a
    WHERE a.sender REGEXP 'xx1|xx2|xx3';
    ```

  - 不匹配(包含)  
    用`not regexp 'xxx'`

### 实现分组排序，类似开窗函数 ###

>类似Oracle和SqlServer的 函数名(列) OVER(选项)
>格式row_number() over(partition by )

- 用变量实现  

  示例1：  

    ```sql
    create table heyf_t10 (empid int ,deptid int ,salary decimal(10,2) );

    select empid,deptid,salary,rank
    from (
        select heyf_tmp.empid,heyf_tmp.deptid,heyf_tmp.salary,@rownum:=@rownum+1,
            if(@pdept=heyf_tmp.deptid,@rank:=@rank+1,@rank:=1) as rank,
            @pdept:=heyf_tmp.deptid
        from (
            select empid,deptid,salary
            from heyf_t10
            order by deptid asc ,salary desc
        ) heyf_tmp ,(select @rownum := 0 , @pdept := null ,@rank := 0) a
    ) result;
    ```

  示例2：  

    ```sql
    SELECT
        -- rownum 判断@sp_id 是否与当前的sp_id一致，一致加1，否则重置为1
        IF(@sp_id = a.sp_id,@i := @i + 1,@i := 1) rownum
        ,a.*
        -- 设置@sp_id 等于上一个 sp_id
        ,(@sp_id := a.sp_id)
    FROM jf_sp_contact a,(SELECT @i := 0,@sp_id := 0) AS b
    WHERE a.sp_id = 3334
    ```

  >注意：示例1生效，而示例2无效，原因是该逻辑是针对按规则进行排序的数据进行标识；

## 索引 ##

### 创建索引 ###

- `ALTER TABLE` 命令用来创建索引

  ```sql
  -- 创建普通索引
  ALTER TABLE table_name ADD INDEX index_name(column_name);
  -- 创建唯一索引（数据列值不唯一不能建）
  ALTER TABLE table_name ADD UNIQUE INDEX idx_name(column_name);
  -- 创建主键索引
  ALTER TABLE table_name ADD PRIMARY KEY (column_name);
  -- 创建前缀索引（只能针对字符串列，列名+数字代表只对前几个字符创建索引）
  ALTER TABLE table_name ADD INDEX index_name(column_name(5));
  -- 创建联合索引
  ALTER TABLE table_name ADD INDEX index_name(column_name1,column_name2...);
  ```

- `CREATE INDEX` 命令可对表增加辅助索引或唯一索引

  ```sql
  CREATE INDEX index_name ON table_name (column_name);
  CREATE UNIQUE INDEX index_name ON table_name (column_name);
  ```

  >不能用 CREATE INDEX 命令创建PRIMARY KEY索引。

### 删除索引 ###

  ```sql
  DROP INDEX index_name ON talbe_name;
  ALTER TABLE table_name DROP INDEX index_name;
  ALTER TABLE table_name DROP PRIMARY KEY;
  ```

  >前两条相同，第三条在主键时用；

### 查看表的索引 ###

- 查看表所有索引的具体情况

  ```sql
  SHOW KEYS FROM tablename;
  SHOW INDEX FROM tablename;
  ```

  >注释：
  >Table 表的名称。  
  >Non_unique 如果索引不能包括重复词，则为0。如果可以，则为1。  
  >Key_name 索引的名称。  
  >Seq_in_index 索引中的列序列号，从1开始。  
  >Column_name 列名称。  
  >Collation 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。  
  >Cardinality 散列程度(基数)，索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。  
  >Sub_part 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。  
  >Packed 指示关键字如何被压缩。如果没有被压缩，则为NULL。  
  >Null 如果列含有NULL，则含有YES。如果没有，则该列含有NO。  
  >Index_type 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。  

- 使用 information_schema 元数据查看索引信息

  ```sql
  -- 查看某一个库下某一张表的索引
  SELECT DISTINCT
      lower(index_name) index_name,
      lower(index_type) type
  FROM
      information_schema.statistics
  WHERE
      table_schema = 'employees' AND table_name = 'employees';
  
  -- 查看某一个库下某一张表的某一个索引
  SELECT
      lower(column_name) column_name,
      seq_in_index column_position
  FROM
      information_schema.statistics
  WHERE
      table_schema = 'employees' AND table_name = 'employees' AND index_name = 'primary';
  ```

## 执行计划管理（基础优化） ##

### 获取执行计划 ###

获取查询语句的简化执行计划

```sql
EXPLAIN
SELECT * FROM tablename LIMIT 10;
-- 或者
DESC
SELECT * FROM tablename LIMIT 10;
```

- 表结构优化建议

  ```sql
  select column from table_name procedure analyse();
  ```

- 强制使用某索引

    ```sql
    FORCE INDEX(索引名)
    ```

- 查询是否有表被锁

    ```sql
    show OPEN TABLES where In_use > 0;
    ```

## 过程，作业和触发器 ##

- 查询作业

    ```sql
    SELECT a.name,b.command
    FROM msdb.dbo.sysjobs a
    INNER JOIN msdb.dbo.sysjobsteps b ON a.job_id = b.job_id
    WHERE b.command LIKE '%P_GZ_HeavyPaste_UpOrder%';
    ```

- 查询过程

    ```sql
    SELECT a.name,b.text
    FROM sys.objects a
    INNER JOIN sys.syscomments b ON a.object_id = b.id
    WHERE a.type = 'P' AND b.text LIKE '%T_SEM_PostSnap%';
    ```

- 判断库中是否存在包含`order`的存储过程

  ```sql
  SELECT * FROM information_schema.ROUTINES a WHERE a.SPECIFIC_NAME LIKE '%order%';
  ```

- 查询触发器

    ```sql
    SELECT * FROM sys.objects WHERE TYPE = 'tr';
    ```

- 查询视图

    ```sql
    SELECT * FROM sys.objects WHERE xtype='V';
    ```
