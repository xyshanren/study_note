<!--
 * @Autor: 逍遥山人
 * @Date: 2019-12-19 17:30:22
 * @LastEditors  : lxc
 * @LastEditTime : 2019-12-20 08:52:27
 * @Descriptiong: 
 -->

# MySQL日常使用笔记 #

## 表及字段的注释 ##

- 新建表以及添加表和字段的注释

    ```sql
    create table t_user(
        ID INT(11) primary key auto_increment  comment '主键',
        NAME VARCHAR(255) comment '姓名',
        CREATE_TIME date comment '创建时间'
    )comment  = '用户信息表';
    ```

- 修改表/字段的注释

    ```sql
    alter table t_user comment  = '修改后的表注释信息(用户信息表)';
    ```

- 修改字段注释

    ```sql
    alter table t_user modify column id int comment '主键ID';
    ```

- 查看所有表的注释

    ```sql
    SELECT table_name 表名, table_comment 表说明
    FROM information_schema.TABLES
    WHERE table_schema = '数据库名'
    ORDER BY table_name;
    ```

- 查询所有表及字段的注释

    ```sql
    SELECT
        a.table_name 表名,
        a.table_comment 表说明,
        b.COLUMN_NAME 字段名,
        b.column_comment 字段说明,
        b.column_type 字段类型,
        b.column_key 约束
    FROM information_schema.TABLES a
    LEFT JOIN information_schema. COLUMNS b ON a.table_name = b.TABLE_NAME
    WHERE a.table_schema = '数据库名'
    ORDER BY a.table_name;
    ```

- 查询某表的所有字段的注释

    ```sql
    select 
        COLUMN_NAME 字段名,
        column_comment 字段说明,
        column_type 字段类型,
        column_key 约束
    from information_schema.columns 
    where table_schema = '数据库名' and table_name = '表名';
    ```

    或者  

    ```sql
    show full columns from 表名;
    ```

- 查看表生成的DDL

    >注意表名不加单引号

    ```sql
    show create table 表名;
    ```

## 查询过程，作业和触发器 ##

- 查询作业

    ```sql
    SELECT a.name,b.command
    FROM msdb.dbo.sysjobs a
    INNER JOIN msdb.dbo.sysjobsteps b ON a.job_id = b.job_id
    WHERE b.command LIKE '%P_GZ_HeavyPaste_UpOrder%';
    ```

- 查询过程

    ```sql
    SELECT a.name,b.text
    FROM sys.objects a
    INNER JOIN sys.syscomments b ON a.object_id = b.id
    WHERE a.type = 'P' AND b.text LIKE '%T_SEM_PostSnap%';
    ```

- 查询触发器

    ```sql
    SELECT * FROM sys.objects WHERE TYPE = 'tr';
    ```

- 查询视图

    ```sql
    SELECT * FROM sysobjects WHERE xtype='V';
    ```

## 连接 ##

- 交叉连接（CROSS JOIN）  
  使用交叉连接的时候，结果集由第一个表的所有行与第二个表的所有行的结合，表之间不需要关系；  
  可用于在统计中构造连续的数据，比如统计每天/周/月的(交易等)数据，为使每天/周/月都有数据，可用交叉连接的方式构造数据；  
  使用形式如下：  

    ```sql
    SELECT  *
    FROM T1
    CROSS JOIN T2;
    ```

## 正则表达式（regexp） ##

- 操作符  
  |模式|描述|
  |:--|:--|
  |^|匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置|
  |$|匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置|
  |.|匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式|
  |[...]|字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'|
  |[^...]|负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'|
  |p1\|p2\|p3|匹配 p1 或 p2 或 p3。例如，'z\|food' 能匹配 "z" 或 "food"。'(z\|f)ood' 则匹配 "zood" 或 "food"|
  |* |匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}|
  |+|匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}|
  |{n}|n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o|
  |{n,m}|m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次|

- 实例
  - 匹配连续数字

    ```sql
    SELECT * FROM ofchatlog a WHERE a.`sender` REGEXP 'jf[0-9]{5}' LIMIT 10;
    ```

  - 匹配三个字符串(或的关系)

    ```sql
    SELECT *
    FROM ofchatlog a
    WHERE a.sender REGEXP 'xx1|xx2|xx3';
    ```

  - 不匹配(包含)  
    用`not regexp 'xxx'`

## 实现开窗函数 ##

>类似Oracle和SqlServer的 函数名(列) OVER(选项)

- 分组排序功能  

   >类似格式row_number() over(partition by )

  示例1：  

    ```sql
    create table heyf_t10 (empid int ,deptid int ,salary decimal(10,2) );

    select empid,deptid,salary,rank
    from (
        select heyf_tmp.empid,heyf_tmp.deptid,heyf_tmp.salary,@rownum:=@rownum+1,
            if(@pdept=heyf_tmp.deptid,@rank:=@rank+1,@rank:=1) as rank,
            @pdept:=heyf_tmp.deptid
        from (
            select empid,deptid,salary
            from heyf_t10
            order by deptid asc ,salary desc
        ) heyf_tmp ,(select @rownum := 0 , @pdept := null ,@rank := 0) a
    ) result;
    ```

  示例2：  

    ```sql
    SELECT
        -- rownum 判断@sp_id 是否与当前的sp_id一致，一致加1，否则重置为1
        IF(@sp_id = a.sp_id,@i := @i + 1,@i := 1) rownum
        ,a.*
        -- 设置@sp_id 等于上一个 sp_id
        ,(@sp_id := a.sp_id)
    FROM jf_sp_contact a,(SELECT @i := 0,@sp_id := 0) AS b
    WHERE a.sp_id = 3334
    ```

  >注意：示例1生效，而示例2无效，原因是该逻辑是针对按规则进行排序的数据进行标识；




